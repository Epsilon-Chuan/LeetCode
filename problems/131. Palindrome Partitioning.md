# 题目

> See [HERE](https://leetcode.com/problems/palindrome-partitioning/).

<div><p>Given a string <em>s</em>, partition <em>s</em> such that every substring of the partition is a palindrome.</p>

<p>Return all possible palindrome partitioning of <em>s</em>.</p>

<p><strong>Example:</strong></p>

<pre><strong>Input:</strong>&nbsp;"aab"
<strong>Output:</strong>
[
  ["aa","b"],
  ["a","a","b"]
]
</pre>
</div>

# Code

## 1. C++

> Cost: ms (), MB ()

```C++

```

## 2. Python

> Cost: 88 ms (39.76%), 13.9 MB ()

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        self.dfs(s, [], ans)
        return ans
    
    def dfs(self, s, path, ans):
        if not s:   # backtracking
            ans.append(path[:])
            return
        for i in range(1, len(s)+1):
            if s[:i] == s[i-1::-1]: # if s[:i] is palindrome.
                path.append(s[:i])
                self.dfs(s[i:], path, ans)
                path.pop()
```
