# 题目

> See [HERE](https://leetcode.com/problems/permutations-ii/).

<div><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>

<p><strong>Example:</strong></p>

<pre><strong>Input:</strong> [1,1,2]
<strong>Output:</strong>
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
</pre>
</div>

# Code

## 1. C++

> Cost: ms (), MB ()

```C++

```

## 2. Python

> What the hell...

> Cost: 1068 ms (), 13.4 MB ()

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        ans = []
        self.dfs(nums, [], ans)
        return ans
    def dfs(self, nums, path, ans):
        if not nums and path not in ans:
            ans.append(path)
        for i in range(len(nums)):
            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], ans) # 华而不实
```
