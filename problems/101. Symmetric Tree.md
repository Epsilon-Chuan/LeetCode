# 题目

> See [HERE](https://leetcode.com/problems/symmetric-tree/).

<div><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>

<p>For example, this binary tree <code>[1,2,2,3,4,4,3]</code> is symmetric:</p>

<pre>    1
   / \
  2   2
 / \ / \
3  4 4  3
</pre>

<p>&nbsp;</p>

<p>But the following <code>[1,2,2,null,3,null,3]</code> is not:</p>

<pre>    1
   / \
  2   2
   \   \
   3    3
</pre>

<p>&nbsp;</p>

<p><b>Note:</b><br>
Bonus points if you could solve it both recursively and iteratively.</p>
</div>

# Code

## 1. C++

> Cost: ms (), MB ()

```C++

```

## 2. Python

> Cost: 32 ms (84.24%), 13.2 MB (65.52%)

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        '''XuChuan's method with poor efficiency.'''
        nextlayer = layer = [root]
        while nextlayer:
            nextlayer = []
            for node in layer:
                if node:
                    nextlayer.append(node.left)
                    nextlayer.append(node.right)
            layer = nextlayer
            if not self.layerIsSymmetric(layer):
                return False
        return True
    def layerIsSymmetric(self, layer):
        left, right = 0, len(layer) - 1
        while left < right:
            if layer[left] and layer[right] and layer[left].val == layer[right].val:
                    left += 1
                    right -= 1
            elif not layer[left] and not layer[right]:
                left += 1
                right -= 1
            else:
                return False
        return True
```
