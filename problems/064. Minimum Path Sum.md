# 题目

> See [HERE](https://leetcode.com/problems/minimum-path-sum/).

<div><p>Given a <em>m</em> x <em>n</em> grid filled with non-negative numbers, find a path from top left to bottom right which <em>minimizes</em> the sum of all numbers along its path.</p>

<p><strong>Note:</strong> You can only move either down or right at any point in time.</p>

<p><strong>Example:</strong></p>

<pre><strong>Input:</strong>
[
&nbsp; [1,3,1],
  [1,5,1],
  [4,2,1]
]
<strong>Output:</strong> 7
<strong>Explanation:</strong> Because the path 1→3→1→1→1 minimizes the sum.
</pre>
</div>

# Code

## 1. C++

> Cost: ms (), MB ()

```C++

```

## 2. Python

> Cost: 52 ms (), 14.4 MB ()

```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        pathSums = grid # give it another name just for better understanding
        for j in range(1, n):
            pathSums[0][j] += pathSums[0][j-1]
        for i in range(1, m):
            pathSums[i][0] += pathSums[i-1][0]
            for j in range(1, n):
                pathSums[i][j] += min(pathSums[i-1][j], pathSums[i][j-1])
        return pathSums[-1][-1]
```
